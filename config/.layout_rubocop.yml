# "Layout::AccessModifierIndentation"
#
# Modifiers should be indented as deep as method definitions,
# or as deep as the class/module keyword, depending on configuration.

Layout/AccessModifierIndentation:
  Enabled: true

# Layout::AlignArray
#
# Check if elements of a multi-line array literal are aligned.

Layout/AlignArray:
  Enabled: false

# Layout::AlignHash
#
# Check if the keys, separators, and values of a multi-line hash literal are aligned.

Layout/AlignHash:
  Enabled: false

# Layout::AlignParameters
#
# Check if parameters on a multi-line method call or definition are aligned.

Layout/AlignParameters:
  Enabled: false

# Layout::BlockAlignment
#
# Checks whether the end keywords are aligned properly for do end blocks.
#
# The value `start_of_block` means that the `end` should be aligned with line
# where the `do` keyword appears.
#
# The value `start_of_line` means it should be aligned with the whole
# expression's starting line.
#
# The value `either` means both are allowed.

Layout/BlockAlignment:
  EnforcedStyleAlignWith: either


# Layout::ConditionPosition
#
# Checks for conditions that are not on the same line as if/while/until.
#
# bad:
#
#   if
#     some_condition
#     do_something
#   end
#
# good:
#
#   if some_condition
#     do_something
#   end
#
  
Layout/ConditionPosition:
  Enabled: false

# Layout::ClosingParenthesesIndentation
#
# Checks the indentation of hanging closing parenthesese in method calls, method definitions and
# grouped expressions. A hanging closing parentheses means ')' preceded by a line break
#
# bad:
#
#  def func(
#    x,
#    y
#    )
#
# good:
#
#  a = b * (x +
#           y
#          )

Layout/ClosingParenthesisIndentation:
  Enabled: true

# Layout::CommentIndentation
#
# Checks the indentation of comments.

Layout/CommentIndentation:
  Enabled: false

# Layput::DefEndAlignment
#
# Checks whether the end keywords of method definitions are aligned properly

Layout/DefEndAlignment:
  EnforcedStyleAlignWith: start_of_line
  AutoCorrect: true

# Layout::DotPosition
#
# Checks the '.' position in multi-line method calls

Layout/DotPosition:
  EnforcedStyle: trailing

# Layout::ElseAlignment
#
# Checks for alignment of `else` keywords

Layout/ElseAlignment:
  Enabled: true

# Layout::EndAlignment
#
# Checks whether the end keywords are aligned properly

Layout/EndAlignment:
  EnforcedStyleAlignWith: keyword
  AutoCorrect: true

# Layout::EndOfLine
#
# Checks for Windows-style line endings in source code.

Layout/EndOfLine:
  Enabled: false

# Layout::FirstArrayElementLineBreak
#
# Checks for a line break before the first element in a multi-line array.
#
# bad:
#
#  [ :a,
#    :b]
#
# good:
#
#  [
#    :a,
#    :b]

Layout/FirstArrayElementLineBreak:
  Enabled: false

# Layout::FirstHashElementLineBreak
#
# Checks for a line break before the first element in a multi-line hash.
#
# bad:
#
#  { a: 1,
#    b: 2}
#
# good:
#
#  {
#    a: 1,
#    b: 2 }

Layout/FirstHashElementLineBreak:
  Enabled: false

# Layout::FirstMethodArgumentLineBreak
#
# Checks for a line break before the first argument in a multi-line method call.
#
# bad:
#
#  method(foo, bar,
#    baz)
#
# good:
#
#  method(
#    foo, bar,
#    baz)
#
# ignored:
#
#  method foo, bar,
#    baz

Layout/FirstMethodArgumentLineBreak:
  Enabled: true

# Layout::FirstMethodParameterLineBreak
#
# Checks for a line break before the first parameter in a multi-line method parameter definition
#
# bad:
#
#  def method(foo, bar,
#      baz)
#    do_something
#  end
#
# good:
#
#  def method(
#      foo, bar,
#      baz)
#    do_something
#  end
#
# ignored:
#
#  def method foo,
#      bar
#    do_something
#  end

Layout/FirstMethodParameterLineBreak:
  Enabled: true

# Layout::ExtraSpacing
#
# Checks for extra/unnecessary whitespace

Layout/ExtraSpacing:
  # When true, allows most uses of extra spacing if the intent is to align
  # things with the previous or next line, not counting empty lines or comment
  # lines.
  AllowForAlignment: true
  # When true, forces the alignment of `=` in assignments on consecutive lines.
  ForceEqualSignAlignment: false

# Layout::IndentAssignment
#
# Checks the indentation of the first line of the right-hand-side of a multi-line assignment.
#
# bad:
#
#  value =
#  if foo
#    'bar'
#  end
#
# good:
#
#  value =
#    if foo
#    'bar'
#  end

Layout/IndentAssignment:
  Enabled: false

# Layout::IndentationConsistency
#
# Checks for inconsistent indentation
#
# bad:
#
#   def test
#     puts "world"
#       puts "here"
#   end

Layout/IndentationConsistency:
  EnforcedStyle: normal

# Layout::IndentationWidth
#
# Checks for indentation that does't use two spaces
#
# bad:
#
#   def test
#    puts "world"
#   end

Layout/IndentationWidth:
  Width: 2
  IgnoredPatterns: []

# Layout::InitialIndentation:
#
# Checks for indentation of the first non-blank non-comment line in a file.

Layout/InitialIndentation:
  Enabled: true

# Layout::BlockEndNewline
#
# Checks whether the end statement of a do..end block is on its own line.
#
# bad:
#
#   apple do |piece|
#     eat(piece) end
#
# good:
#
#   apple do |piece|
#     eat(piece)
#   end

Layout/BlockEndNewline:
  Enabled: true

# Layout::EmptyLineBetweenDefs
#
# Checks whether method definitions are separated by empty lines

Layout/EmptyLineBetweenDefs:
  Enabled: true

# Layout::EmptyLines
#
# Checks for two or more consecutive blank lines

Layout/EmptyLines:
  Enabled: true

# StLayoutyle::EmptyLinesAroundAccessModifier
#
# Access modifiers should be surrounded by blank spaces.

Layout/EmptyLinesAroundAccessModifier:
  Enabled: false

# Layout::EmptyLinesAroundBlockBody
#
# Checks if empty lines around the bodies of blocks match the configuration.
#
# bad:
#
#  foo do |bar|
#    ...
#  end
#
# good:
#
#  foo do |bar|
#
#    ....
#
#  end
#
# ( This helps in readability of code )

Layout/EmptyLinesAroundBlockBody:
  Enabled: false

# Layout::EmptyLinesAroundClassBody
#
# Checks if empty lines around the bodies of classes match the configuration

Layout/EmptyLinesAroundClassBody:
  Enabled: false

# Layout::EmptyLinesAroundMethodBody
#
# Checks if empty lines exist around the bodies of methods.

Layout/EmptyLinesAroundMethodBody:
  Enabled: false

# Layout::EmptyLinesAroundModuleBody
#
# Checks if empty lines around the bodies of modules match the configuration

Layout/EmptyLinesAroundModuleBody:
  Enabled: false

# Layout::LeadingCommentSpace
#
# Checks whether comments have a leading space after the '#'
# Note: Leading space is not required for RDoc special syntax, like #++, #-, #:nodoc, etc.

Layout/LeadingCommentSpace:
  Enabled: true

# Layout::RescueEnsureAlignment
#
# Checks whether the rescue and ensure keywords are aligned properly
#
# bad:
#  begin
#    something
#    rescue
#    puts 'error'
#  end
#
# good:
#
#  begin
#    something
#  rescue
#    puts 'error'
#  end

Layout/RescueEnsureAlignment:
  Enabled: true

# Layout::SpaceBeforeSemicolon
#
# Checks for semicolon (;) preceded by space.

Layout/SpaceBeforeSemicolon:
  Enabled: true

# Layout::CaseIndentation
#
# Checks how the 'when's of a case expression are indented in relation to its
# 'case' or 'end' keyword
#
# bad:
#
#  case foo
#    when *condition
#     bar
#   when baz
#     foobar
#  end
#
# good:
#
#  case foo
#  when baz
#    foobar
#  when *condition
#    bar
#  end

Layout/CaseIndentation:
  Enabled: false

# Layout::IndentFirstArgument
#
# Checks the indentation of the first parameter in a method call.
# ( This cop checks only for first parameter indentation )
# bad:
#
#  some_method(
#  first_param,
#  second_param)
#
# good:
#
#  some_method(
#    first_param,
#  second_param)

Layout/IndentFirstArgument:
  EnforcedStyle: special_for_inner_method_call_in_parentheses

# Layout::IndentFirstArrayElement
#
# Checks for indentation of the first element in the array literal where
# the opening bracket and the first elements are on separate lines.
# ( Array literals shall have their first element indented one step (2 spaces)
#   more than the start of the line where the opening bracket is )

Layout/IndentFirstArrayElement:
  Enabled: false

# Layout::IndentFirstHashElement
#
# Same as the Indent Array but in case of hash

Layout/IndentFirstHashElement:
  Enabled: false

# Layout::MultilineArrayBraceLayout
#
# Checks that the closing brace in an array literal is either on the
# same line as the last array element, or a new line.
#
# symmetrical: closing brace is positioned in same way as opening brace

Layout/MultilineArrayBraceLayout:
  EnforcedStyle: symmetrical

# Layout::MultilineAssignmentLayout
#
# Checks whether the multiline assignments have a new line after
# the assignment operator
#
# bad: (with EnforcedStyle set to new_line)
#
#  foo = if expression
#    'bar'
#  end
#
# good: (with EnforcedStyle set to same_line)
#
#  foo = if expression
#    'bar'
#  end

Layout/MultilineAssignmentLayout:
  EnforcedStyle: same_line

# Layout::MultilineBlockLayout
#
# Checks whether the multiline do end blocks have a newline after the start of the block.
# Additionally, it checks whether the block arguments, if any, are on the same line as the start of the block.
#
# bad:
#
#  blah do
#    |i| foo(i)
#    bar(i)
#  end
#
# good:
#
#  blah do |i|
#    foo(i)
#    bar(i)
#  end

Layout/MultilineBlockLayout:
  Enabled: true

# Layout::MultilineHashBraceLayout
#
# Checks that the closing brace in a hash literal is either on the
# same line as the last hash element, or a new line
#
# Symmetrical:
#   { a: 1,
#     b: 2 }
#
#   {
#     a: 1,
#     b: 2
#   }

Layout/MultilineHashBraceLayout:
  EnforcedStyle: symmetrical